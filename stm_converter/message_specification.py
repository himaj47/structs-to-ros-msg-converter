from os import getcwd, walk
import ros2interface.api as interface

SIGNED_INTEGER_TYPES = (
    'int8', 'int16', 'int32', 'int64'
)

UNSIGNED_INTEGER_TYPES = (
    'uint8', 'uint16', 'uint32', 'uint64'
)

FLOATING_POINT_TYPES = (
    'float32', 'float64'
)

BASIC_TYPES = (
    *SIGNED_INTEGER_TYPES, 
    *UNSIGNED_INTEGER_TYPES,
    *FLOATING_POINT_TYPES,
    'char', 'string', 'bool'
)


class BasicType:
    __slots__ = ('typename_', )

    def __init__(self, type: str):
        # assert type in BASIC_TYPES
        self.typename_ = None

        if type in BASIC_TYPES:
            self.typename_ = type
        else:
            self.check_type(type)

    def check_type(self, type:str):
        msg = type.split(f"::")[1].title()
        filename = msg + ".msg"
        print(f"check_type = {filename}")
        # found_interface = None
        # checking if any msg exists
        is_present = False
        pkgs = list(interface.get_interface_packages().keys())

        msg_interfaces = interface.get_message_interfaces(pkgs)   
        for pkg, msgs in msg_interfaces.items():
            if "msg/" + msg in msgs:
                # print(pkg) 
                is_present = True
                self.typename_ = f"{pkg}/msg/{msg}"
                print(f"interface found = {self.typename_}")

        if not is_present:
        # checking if any autogenerated msg present in the cwd
        # assuming namespace typed struct
            print(f"cwd = {getcwd()}")
            for root, dirs, files in walk(getcwd()):
                if filename in files:
                    is_present = True
                    self.typename_ = f"<interface_name>/msg/{msg}"
                else:
                    print(f"first need to create a msg file {filename}")
                    self.typename_ = type


class Field:
    __slots__ = ('field_name_', 'type_', 'is_array_', 'array_size_', )

    def __init__(self, field_name: str, type: BasicType, is_array=False, array_size=None):
        self.field_name_ = field_name
        self.type_ = type
        self.is_array_ = is_array
        self.array_size_ = array_size


class MessageSpecification:
    __slots__ = ('msg_name_', 'fields_', 'constants_', 'struct_name_')

    def __init__(self, msg_name = "", ):
        self.msg_name_ = msg_name
        self.struct_name_ = ""
        self.fields_ = []
        self.constants_ = []

    def set_field(self, field: Field):
        self.fields_.append(field)

    def get_fields(self):
        all_fields = {}
        for field in self.fields_:
            all_fields[field.field_name_] = (field.type_.typename_, field.is_array_, field.array_size_)

        return all_fields
    
    def get_types(self):
        type_list = []
        for _, field_specs in self.get_fields().items():
            if field_specs[0] not in type_list:
                type_list.append(field_specs[0])

        return type_list

    def convert(self, parsed_data):
        for msg in parsed_data.items():
            self.msg_name_ = msg[0].title()
            for name, type in msg[1].items():
                is_array = False
                if type.find("[]") != -1:
                    is_array = True

                field = Field(name, BasicType(type), is_array=is_array)
                self.set_field(field=field)

    def count_fields(self):
        return len(self.fields_)

    def set_constants(self):
        pass


def main():
    num = MessageSpecification("Num")

    a = Field("a", BasicType('int32'))
    b = Field("b", BasicType('float32'))

    num.set_field(a)
    num.set_field(b)

    msg_specs = num.get_fields()
    print(msg_specs.items())

    msg = {"point": {'x': 'float64', 'y': 'float64', 'z': 'float64'}}
    point = MessageSpecification("Point")
    point.convert(msg)

    # print(point.msg_name_)
    # print(point.get_fields())

    # is_primitive_type = BasicType("")
    print("ns::point".split("::"))

if __name__ == '__main__':
    main()